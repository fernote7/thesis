# The Heston Model Implementation

```{r results, echo=FALSE, message=FALSE, results='asis', eval=FALSE}
source("/home/fteixeira/Documents/thesis/r_code/results.r")
```

In section \@ref(hes1) we presented Heston's SDE system in one of its structures. Another common way [@broadie2006exact; @andersen; @kahl2006fast] to write down the system is using the property presented in \@ref(corr) as in equation \@ref(eq:heston2).   

\begin{align}
\label{eq:heston2}
\begin{split}
dS_t &= \mu S_t dt + \rho \sqrt{V_t} dB_t + \sqrt{1 - \rho^2} \sqrt{V_t} S_t dW_t \\
dV_t &= k(\theta - V_t)dt + \sigma \sqrt{V_t} dB_t 
\end{split}
\end{align}




## Characteristic Function

The Heston model characteristic function is firstly presented in the 1993 Steven Heston's paper [@heston1993closed] and is described below [@dunn2014estimating]:

\begin{align}
f(S_t, V_t, t) = e^{A(T-t)+B(T-t)S_t + C(T-t)V_t + i \phi S_t}
\end{align}

If we let $\tau = T-t$, then the explicit form of the Heston characteristic function is:

\begin{align*}
f(i \phi) &= e^{A(\tau)+B(\tau)S_t + C(\tau)V_t + i \phi S_t} \\
A(\tau) &= r i \phi \tau + \frac{\kappa \theta}{\sigma^2} \left[ - (\rho \sigma i \phi - \kappa - M) \tau - 2 \ln\left(\frac{1-N e^{M \tau}}{1-N}\right) \right] \\
B(\tau) &= 0 \\
C(\tau) &= \frac{(e^{M \tau}-1)(\rho \sigma i \phi - \kappa - M)}{\sigma^2 (1-N e^{M \tau})} \\
\text{Where:} & \\
M &= \sqrt{(\rho \sigma i \phi - \kappa)^2 + \sigma^2 (i \phi + \phi^2)} \\
N &= \frac{\rho \sigma i \phi - \kappa - M}{\rho \sigma i \phi - \kappa + M} \\
\end{align*}

This function is the driving force behind the following formula, that calculates the fair valur of a European call option at time $t$, given a strike price $K$, that expires at time $T$ [@dunn2014estimating]:

\begin{align} 
\label{eq:cfheston}
\begin{split}
C = & \frac{1}{2} S(t) + \frac{e^{-r(T-t)}}{\pi}\int_{0}^{\infty}{\Re \left[ \frac{K^{-i \phi} f(i \phi + 1)}{i \phi} \right] d\phi} \\
& -Ke^{-r(T-t)}\left( \frac{1}{2} + \frac{1}{\pi} \int_{0}^{\infty}{\Re \left[ \frac{K^{-i \phi} f(i \phi)}{i \phi} \right]}  d\phi \right)
\end{split}
\end{align}




## Euler Scheme - Full Truncation

We present here the Euler Scheme - Full Truncation algorithm [@broadie2006exact, dunn2014estimating, andersen] along with some insights on how it was implemented in R. The Euler discretization brings approximation paths to stock prices and variance processes. If we set $t_0 = 0 < t_1 < \dots < t_M = T$ as partitions of a time interval of $M$ equal segments of lenght $\delta t$, we have the following discretization for the stock price:

\begin{align}
S_{t+1} = S_t + rS_t + \sqrt{V_t} S_t Z_s
\end{align}

\noindent
And for the variance process:

\begin{align}
V_{t+1} = V_t + \kappa (\theta - V_t) + \sigma \sqrt{V_t} Z_v
\end{align}

\noindent
$Z_s$ being a standard normal random variable, i.e. $N\sim(0,1)$, we set $Z_t$ and $Z_v$ as two independent standard normal random variables and $Z_s$ and $Z_v$ having correlation $\rho$. This means we can write $Z_s = \rho Z_v + \sqrt{1-\rho^2} Z_t$

The immediate observable problem in the proposed discretization scheme is that $V$ can become negative with non-zero probability making the computation of $\sqrt{V_t}$ impossible [@andersen]. There are several proposed fixes that can be used, we chose the Full-Truncation (FT) and rewrite the equations as follows:


\begin{align}
S_{t+1} &= S_t + rS_t + \sqrt{V_{t}^{+}} S_t Z_s \\
V_{t+1} &= V_t + \kappa (\theta - V_{t}^{+}) + \sigma \sqrt{V_{t}^{+}} Z_v
\end{align}

\noindent
Where we use the notation $V_{t}^{+} = \max(V_{t}, 0)$. 

```{r calle, eval=FALSE, echo=FALSE}
hestoneuler <- function(S, X, r, v, theta, rho, k, sigma, t = 0, 
                        dt = NULL, tau = 1, N, sensibility = 15){

    set.seed(1)

    if(is.null(dt)){ dt <- (tau-t)/1000}

    ST <- NULL
    aux <- NULL
    sqrt_dt <- sqrt(dt)

    for(i in seq(t,tau,dt)){
        # browser()
        Zv <- rnorm(N)
        Zt <- rnorm(N)
        Zs <- rho * Zv + (sqrt(1 - (rho^2)) * Zt)

        # v[v <= 0] = 0

        aux <- v
        aux[v < 0] <- 0
        sqrt_aux <- sqrt(aux)
        S <- S * (1 + r * dt + sqrt_aux * Zs * sqrt_dt)
        S[S <= 0] = 0

        v <- v + k * dt * (theta - aux) + 
          sigma * sqrt_aux * Zv * sqrt_dt


        ST <- rbind(ST,S)
    }

    rm(aux, v, Zv, Zt, Zs, S)

    ST <- as.matrix(ST, ncol=N)
    # matplot(graf, type = 'l')
    # abline(h=X, lwd=2, col='red')
    media <- c()

    for (j in (X-sensibility):(X+sensibility)){

        Result <- ST[nrow(ST),] - j
        Result[Result <= 0] <- 0
        media <-c(media, mean(Result))

    }

    media <- media * exp(-r*tau)
    # plot(media, ylab = "Call price", xlab = "Strike price")


    Result <- ST[nrow(ST),] - X
    Result[Result <= 0] = 0
    call = mean(exp(-r*tau)*Result)

    lista = list('call' = call, 'Result' = Result, 
                 'Spot' = ST, 'sensib' = media)
    return(lista)
}
```


## Kahl-Jackel

Kahl-Jackel propose a discretization method they refer to as the ``IJK'' method  [@andersen; @kahl2006fast] that coupled with the implicit Milstein scheme for the variance lands the system of equations \@ref(eq:kj1) and \@ref(eq:kj2). It is possible to verify that this discretization always results in positive paths for $V$ if $4 \kappa \theta > \sigma^2$. Unfortunately, this inequality is rarely satisfied when we plug real market data to calibrate the parameters.

\begin{small}
\begin{align}
\label{eq:kj1}
\ln \hat{S}(t + \Delta) &= \ln \hat{S}(t) - \frac{\Delta}{4}\left( \hat{V}(t+\Delta) + \hat{V}(t) \right) + \rho \sqrt{\hat{V}(t)}Z_v\sqrt{\Delta} \\ \nonumber
&+ \frac{1}{2} \left( \sqrt{\hat{V}(t+\Delta)} + \sqrt{\hat{V}(t)} \right) \left( Z_S \sqrt{\Delta} - \rho Z_V \sqrt{\Delta}\right) + \frac{1}{4} \sigma \rho \Delta \left( Z_{V}^{2} - 1 \right) \\
\label{eq:kj2}
\hat{V}(t+\Delta) &= \frac{\hat{V}(t) + \kappa \theta \Delta + \sigma \sqrt{\hat{V}(t)}Z_V \sqrt{\Delta}+ \frac{1}{4}\sigma^2 \Delta \left(Z_V^2-1 \right)}{1+ \kappa \Delta}
\end{align}
\end{small}

```{r callkj, eval=FALSE, echo=FALSE}
Hestoncallkj <- function(S, X, r, q, v, theta, rho, k, sigma, 
                         t = 0, dt = NULL, tau = 1, N, 
                         sensibility = 15){

    if(is.null(dt)){ dt <- (T-t)/1000}

    v <- rep(v,N)
    theta<- rep(theta,N)
    graf <- NULL
    S <- log(S)


    for(i in seq(t,tau,dt)){
     # browser()
    Zv <- rnorm(N)
    Zt <- rnorm(N)
    Zs <- rho * Zv + sqrt(1 - rho^2) * Zt


    vt <- (v + k * theta * dt + sigma * sqrt(v) * Zv * sqrt(dt) +
              (1/4) * sigma^2 * dt * ((Zv)^2 - 1))/(1 + k * dt)

    # print(vt)

    # if(!length(vt[vt <= 0]) == 0 & length(vt[vt <= 0]) >= 1){
    #     # browser()
    vt[vt <= 0] <- v[vt <= 0] + k * dt * (theta[vt <= 0] - 
                    pmax(v[vt <= 0],0)) + sigma * 
                    sqrt(pmax(v[vt <= 0],0)) * Zv[vt <= 0] * sqrt(dt)
    v <- vt
    v[v<=0] <- 0

    # }

    S <- S + (r - (v+vt)/4) * dt + rho * sqrt(pmax(v,0)) * 
          Zv * sqrt(dt) +
          (1/2) * (sqrt(pmax(v,0)) + sqrt(pmax(vt,0))) * 
          (Zs + rho * Zv) * 
          sqrt(dt) +
          ((rho * sigma * dt)/2) * ((Zv)^2 - 1)

    S[S <= 0] = 0
    graf <- rbind(graf,S)


    }

     # browser()

    graf <- as.matrix(graf, ncol=N)
    ST <- graf
    # matplot(graf, type = 'l')
    # abline(h=log(X), lwd=2, col='red')

    media <- c()

    # browser()

    for (j in (X-sensibility):(X+sensibility)){

        Result <- exp(ST[nrow(ST),]) - j
        Result[Result <= 0] <- 0
        media <-c(media, mean(Result))

    }

    media <- media * exp(-r*tau)


    # browser()


    Result <- exp(ST[nrow(ST),]) - X
    Result[Result <= 0] = 0
    call = mean(exp(-r*tau)*Result)

    lista = list('call' = call, 'Result' = Result, 
                 'Spot' = graf, 'sensib' = media)
    return(lista)

}
```



## Exact Algorithm 

In 2006, Broadie-Kaya [@broadie2006exact] propose a method that has a faster convergence rate, $\mathcal{O} \left( s^{-1/2}  \right)$ than some of the more famous schemes, such as Euler's and Milstein's discretizations. They build their idea to generate an exact sample from the distribution of the terminal stock price based on numerous papers [@heston1993closed, @scott1996, @willard1997, @romano1997]. 

The algorithm used to generate the model consists in four steps as follows:
 
\begin{itemize}
\item [\textit{Step} 1.] Generate a sample of $V_t$ given $V_0$
\item [\textit{Step} 2.] Generate a sample of $\int_0^t V_sds$ given $V_t$
\item [\textit{Step} 3.] Compute $\int_0^t \sqrt{V_s}dB_s$
\item [\textit{Step} 4.] teste
\end{itemize}


```{r callea, eval=FALSE, echo=FALSE}
hestonea <- function(S, X, r, v, theta, rho, k, sigma, t = 0, 
                     dt = NULL, tau = 1, N, sensibility = 15){

    if(is.null(dt)){ dt <- (tau-t)/1000}

    ST <- NULL

    d <- (4 * k * theta)/(sigma)^2
    c0 <- (sigma^2 * (1 - exp(-k*dt)))/(4*k)

    # browser()

    for(i in seq(t,tau,dt)){

        # sampling V
        lambda <- (4*k*exp(-k*dt)*v)/(sigma^2 * (1-exp(-k*dt)))
        vt <- c0 * rchisq(n = N, df = d, ncp = lambda)

        # Sampling int{V}
        int_v <- dt * ((1/2) * v + (1/2) * vt)

        # Sampling int{v}dw
        int_vdw <- (1/sigma) * (vt - v - k * theta * dt + k  * int_v)

        # Sampling S
        m <- log(S) + (r * dt - (1/2) * int_v + rho * int_vdw)
        std <- sqrt((1 - rho^2)) * sqrt(int_v)
        S <- exp(m + std * rnorm(N))
        v <- vt
        ST <- rbind(ST,S)
    }

    ST <- as.matrix(ST, ncol=N)
    # matplot(graf, type = 'l')
    # abline(h=X, lwd=2, col='red')
    media <- c()

    for (j in (X-sensibility):(X+sensibility)){

        Result <- ST[nrow(ST),] - j
        Result[Result <= 0] <- 0
        media <-c(media, mean(Result))

    }

    media <- media * exp(-r*tau)
    # plot(media, ylab = "Call price", xlab = "Strike price")


    Result <- ST[nrow(ST),] - X
    Result[Result <= 0] = 0
    call = mean(exp(-r*tau)*Result)

    lista = list('call' = call, 'Result' = Result, 
                 'Spot' = ST, 'sensib' = media)
    return(lista)
}
```






<!-- Broadie Kaya -->



<!-- Required to number equations in HTML files -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>


<!-- ## Teste -->

<!-- ```{r call, eval=FALSE} -->
<!-- Call <- function(S,X,tau,r,q,sigma){ -->

<!--   # S = spot -->
<!--   # X = strike -->
<!--   # tau = time to maturity -->
<!--   # r = riskfree rate -->
<!--   # q = dividend yield -->
<!--   # sigma = standard deviation -->

<!--   d1 = (log(S/X) + (r - q + sigma^2/2) * tau) / (sqrt(sigma^2 * tau)) -->
<!--   d2 = d1 - sqrt(sigma^2 * tau) -->
<!--   c0 = S * exp(-q * tau) * pnorm(d1,0,1) - -->
<!--        X * exp(-r * tau) * pnorm(d2,0,1) -->

<!--   return(c0) -->
<!-- } -->
<!-- ``` -->

\clearpage

```{r euler_call, eval=FALSE, echo=FALSE}
require(NMOF)
setwd("../rnmethods")
source("../rnmethods/R/euler_heston.R")

```