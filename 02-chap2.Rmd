# The Heston Model Implementation

```{r results, echo=FALSE, message=FALSE, results='asis', eval=FALSE}
source("/home/fteixeira/Documents/thesis/r_code/results.r")
```


## Characteristic Function

The Heston model characteristic function is firstly presented in the 1993 Steven Heston's paper [-@heston1993closed] and is described below [@dunn2014estimating]:

\begin{align}
f(S_t, V_t, t) = e^{A(T-t)+B(T-t)S_t + C(T-t)V_t + i \phi S_t}
\end{align}

If we let $\tau = T-t$, then the explicit form of the Heston characteristic function is:

\begin{align*}
f(i \phi) &= e^{A(\tau)+B(\tau)S_t + C(\tau)V_t + i \phi S_t} \\
A(\tau) &= r i \phi \tau + \frac{k \theta}{\sigma^2} \left[ - (\rho \sigma i \phi - k - M) \tau - 2 \ln\left(\frac{1-N e^{M \tau}}{1-N}\right) \right] \\
B(\tau) &= 0 \\
C(\tau) &= \frac{(e^{M \tau}-1)(\rho \sigma i \phi - k - M)}{\sigma^2 (1-N e^{M \tau})} \\
\text{Where:} & \\
M &= \sqrt{(\rho \sigma i \phi - k)^2 + \sigma^2 (i \phi + \phi^2)} \\
N &= \frac{\rho \sigma i \phi - k - M}{\rho \sigma i \phi - k + M} \\
\end{align*}

This function is the driving force behind the following formula, that calculates the fair valur of a European call option at time $t$, given a strike price $K$, that expires at time $T$ [@dunn2014estimating]:

\begin{align} 
\label{eq:cfheston}
\begin{split}
C = & \frac{1}{2} S(t) + \frac{e^{-r(T-t)}}{\pi}\int_{0}^{\infty}{\Re \left[ \frac{K^{-i \phi} f(i \phi + 1)}{i \phi} \right] d\phi} \\
& -Ke^{-r(T-t)}\left( \frac{1}{2} + \frac{1}{\pi} \int_{0}^{\infty}{\Re \left[ \frac{K^{-i \phi} f(i \phi)}{i \phi} \right]}  d\phi \right)
\end{split}
\end{align}




## Euler Scheme - Full Truncation

We present here the Euler Scheme - Full Truncation algorithm [@broadie2006exact, dunn2014estimating, andersen2007efficient] along with some insights on how it was implemented in the R programming language [@rlang]. The Euler discretization brings approximation paths to stock prices and variance processes. If we set $t_0 = 0 < t_1 < \dots < t_M = T$ as partitions of a time interval of $M$ equal segments of lenght $\delta t$, we have the following discretization for the stock price:

\begin{align}
S_{t+1} = S_t + rS_t + \sqrt{V_t} S_t Z_s
\end{align}

\noindent
And for the variance process:

\begin{align}
V_{t+1} = V_t + k (\theta - V_t) + \sigma \sqrt{V_t} Z_v
\end{align}

\noindent
$Z_s$ being a standard normal random variable, i.e. $N~(0,1)$, we set $Z_t$ and $Z_v$ as two independent standard normal random variables and $Z_s$ and $Z_v$ having correlation $\rho$. This means we can write $Z_s = \rho Z_v + \sqrt{1-\rho^2} Z_t$

The immediate observable problem in the proposed discretization scheme is that $V$ can become negative with non-zero probability making the computation of $\sqrt{V_t}$ impossible [@andersen2007efficient]. There are several proposed fixes that can be used, we chose the Full-Truncation (FT) and rewrite the equations as follows:


\begin{align}
S_{t+1} &= S_t + rS_t + \sqrt{V_{t}^{+}} S_t Z_s \\
V_{t+1} &= V_t + k (\theta - V_{t}^{+}) + \sigma \sqrt{V_{t}^{+}} Z_v
\end{align}

\noindent
Where we use the notation $V_{t}^{+} = \max(V_{t}, 0)$. 

```{r calle, eval=FALSE}
hestoneuler <- function(S, X, r, v, theta, rho, k, sigma, t = 0, 
                        dt = NULL, tau = 1, N, sensibility = 15){

    set.seed(1)

    if(is.null(dt)){ dt <- (tau-t)/1000}

    ST <- NULL
    aux <- NULL
    sqrt_dt <- sqrt(dt)

    for(i in seq(t,tau,dt)){
        # browser()
        Zv <- rnorm(N)
        Zt <- rnorm(N)
        Zs <- rho * Zv + (sqrt(1 - (rho^2)) * Zt)

        # v[v <= 0] = 0

        aux <- v
        aux[v < 0] <- 0
        sqrt_aux <- sqrt(aux)
        S <- S * (1 + r * dt + sqrt_aux * Zs * sqrt_dt)
        S[S <= 0] = 0

        v <- v + k * dt * (theta - aux) + 
          sigma * sqrt_aux * Zv * sqrt_dt


        ST <- rbind(ST,S)
    }

    rm(aux, v, Zv, Zt, Zs, S)

    ST <- as.matrix(ST, ncol=N)
    # matplot(graf, type = 'l')
    # abline(h=X, lwd=2, col='red')
    media <- c()

    for (j in (X-sensibility):(X+sensibility)){

        Result <- ST[nrow(ST),] - j
        Result[Result <= 0] <- 0
        media <-c(media, mean(Result))

    }

    media <- media * exp(-r*tau)
    # plot(media, ylab = "Call price", xlab = "Strike price")


    Result <- ST[nrow(ST),] - X
    Result[Result <= 0] = 0
    call = mean(exp(-r*tau)*Result)

    lista = list('call' = call, 'Result' = Result, 
                 'Spot' = ST, 'sensib' = media)
    return(lista)
}
```


## Kahl-Jackel








```{r callkj, eval=FALSE}
Hestoncallkj <- function(S, X, r, q, v, theta, rho, k, sigma, 
                         t = 0, dt = NULL, tau = 1, N, 
                         sensibility = 15){

    if(is.null(dt)){ dt <- (T-t)/1000}

    v <- rep(v,N)
    theta<- rep(theta,N)
    graf <- NULL
    S <- log(S)


    for(i in seq(t,tau,dt)){
     # browser()
    Zv <- rnorm(N)
    Zt <- rnorm(N)
    Zs <- rho * Zv + sqrt(1 - rho^2) * Zt


    vt <- (v + k * theta * dt + sigma * sqrt(v) * Zv * sqrt(dt) +
              (1/4) * sigma^2 * dt * ((Zv)^2 - 1))/(1 + k * dt)

    # print(vt)

    # if(!length(vt[vt <= 0]) == 0 & length(vt[vt <= 0]) >= 1){
    #     # browser()
    vt[vt <= 0] <- v[vt <= 0] + k * dt * (theta[vt <= 0] - 
                    pmax(v[vt <= 0],0)) + sigma * 
                    sqrt(pmax(v[vt <= 0],0)) * Zv[vt <= 0] * sqrt(dt)
    v <- vt
    v[v<=0] <- 0

    # }

    S <- S + (r - (v+vt)/4) * dt + rho * sqrt(pmax(v,0)) * 
          Zv * sqrt(dt) +
          (1/2) * (sqrt(pmax(v,0)) + sqrt(pmax(vt,0))) * 
          (Zs + rho * Zv) * 
          sqrt(dt) +
          ((rho * sigma * dt)/2) * ((Zv)^2 - 1)

    S[S <= 0] = 0
    graf <- rbind(graf,S)


    }

     # browser()

    graf <- as.matrix(graf, ncol=N)
    ST <- graf
    # matplot(graf, type = 'l')
    # abline(h=log(X), lwd=2, col='red')

    media <- c()

    # browser()

    for (j in (X-sensibility):(X+sensibility)){

        Result <- exp(ST[nrow(ST),]) - j
        Result[Result <= 0] <- 0
        media <-c(media, mean(Result))

    }

    media <- media * exp(-r*tau)


    # browser()


    Result <- exp(ST[nrow(ST),]) - X
    Result[Result <= 0] = 0
    call = mean(exp(-r*tau)*Result)

    lista = list('call' = call, 'Result' = Result, 
                 'Spot' = graf, 'sensib' = media)
    return(lista)

}
```



## Exact Algorithm 



```{r callea, eval=FALSE}
hestonea <- function(S, X, r, v, theta, rho, k, sigma, t = 0, 
                     dt = NULL, tau = 1, N, sensibility = 15){

    if(is.null(dt)){ dt <- (tau-t)/1000}

    ST <- NULL

    d <- (4 * k * theta)/(sigma)^2
    c0 <- (sigma^2 * (1 - exp(-k*dt)))/(4*k)

    # browser()

    for(i in seq(t,tau,dt)){

        # sampling V
        lambda <- (4*k*exp(-k*dt)*v)/(sigma^2 * (1-exp(-k*dt)))
        vt <- c0 * rchisq(n = N, df = d, ncp = lambda)

        # Sampling int{V}
        int_v <- dt * ((1/2) * v + (1/2) * vt)

        # Sampling int{v}dw
        int_vdw <- (1/sigma) * (vt - v - k * theta * dt + k  * int_v)

        # Sampling S
        m <- log(S) + (r * dt - (1/2) * int_v + rho * int_vdw)
        std <- sqrt((1 - rho^2)) * sqrt(int_v)
        S <- exp(m + std * rnorm(N))
        v <- vt
        ST <- rbind(ST,S)
    }

    ST <- as.matrix(ST, ncol=N)
    # matplot(graf, type = 'l')
    # abline(h=X, lwd=2, col='red')
    media <- c()

    for (j in (X-sensibility):(X+sensibility)){

        Result <- ST[nrow(ST),] - j
        Result[Result <= 0] <- 0
        media <-c(media, mean(Result))

    }

    media <- media * exp(-r*tau)
    # plot(media, ylab = "Call price", xlab = "Strike price")


    Result <- ST[nrow(ST),] - X
    Result[Result <= 0] = 0
    call = mean(exp(-r*tau)*Result)

    lista = list('call' = call, 'Result' = Result, 
                 'Spot' = ST, 'sensib' = media)
    return(lista)
}
```






<!-- Broadie Kaya -->



<!-- Required to number equations in HTML files -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>


<!-- ## Teste -->

<!-- ```{r call, eval=FALSE} -->
<!-- Call <- function(S,X,tau,r,q,sigma){ -->

<!--   # S = spot -->
<!--   # X = strike -->
<!--   # tau = time to maturity -->
<!--   # r = riskfree rate -->
<!--   # q = dividend yield -->
<!--   # sigma = standard deviation -->

<!--   d1 = (log(S/X) + (r - q + sigma^2/2) * tau) / (sqrt(sigma^2 * tau)) -->
<!--   d2 = d1 - sqrt(sigma^2 * tau) -->
<!--   c0 = S * exp(-q * tau) * pnorm(d1,0,1) - -->
<!--        X * exp(-r * tau) * pnorm(d2,0,1) -->

<!--   return(c0) -->
<!-- } -->
<!-- ``` -->

\clearpage

```{r euler_call, eval=FALSE}
require(NMOF)
setwd("../rnmethods")
source("../rnmethods/R/euler_heston.R")

```