<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <meta name="description" content="">
  <meta name="generator" content="bookdown 0.4 and GitBook 2.6.7">

  <meta property="og:title" content="" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="" />
  
  
  

<meta name="author" content="Fernando O. Teixeira">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="2-lt-review.html">
<link rel="next" href="4-resultados.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./"></a></li>
<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="chapter" data-level="2" data-path="2-lt-review.html"><a href="2-lt-review.html"><i class="fa fa-check"></i><b>2</b> Theoretical Framework</a><ul>
<li class="chapter" data-level="2.1" data-path="2-lt-review.html"><a href="2-lt-review.html#stochastic-calculus"><i class="fa fa-check"></i><b>2.1</b> Stochastic Calculus</a><ul>
<li class="chapter" data-level="2.1.1" data-path="2-lt-review.html"><a href="2-lt-review.html#stochastic-differential-equation---sde"><i class="fa fa-check"></i><b>2.1.1</b> Stochastic differential equation - SDE</a></li>
<li class="chapter" data-level="2.1.2" data-path="2-lt-review.html"><a href="2-lt-review.html#brownian-motion"><i class="fa fa-check"></i><b>2.1.2</b> Brownian Motion</a></li>
<li class="chapter" data-level="2.1.3" data-path="2-lt-review.html"><a href="2-lt-review.html#itos-integral"><i class="fa fa-check"></i><b>2.1.3</b> Itô’s Integral</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="2-lt-review.html"><a href="2-lt-review.html#black-scholes-model"><i class="fa fa-check"></i><b>2.2</b> Black-Scholes Model</a><ul>
<li class="chapter" data-level="2.2.1" data-path="2-lt-review.html"><a href="2-lt-review.html#basics"><i class="fa fa-check"></i><b>2.2.1</b> Basics</a></li>
<li class="chapter" data-level="2.2.2" data-path="2-lt-review.html"><a href="2-lt-review.html#limitations"><i class="fa fa-check"></i><b>2.2.2</b> Limitations</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="2-lt-review.html"><a href="2-lt-review.html#stochastic-volatility-models"><i class="fa fa-check"></i><b>2.3</b> Stochastic Volatility models</a><ul>
<li class="chapter" data-level="2.3.1" data-path="2-lt-review.html"><a href="2-lt-review.html#cir"><i class="fa fa-check"></i><b>2.3.1</b> Cox-Ingersoll-Ross model</a></li>
<li class="chapter" data-level="2.3.2" data-path="2-lt-review.html"><a href="2-lt-review.html#hes1"><i class="fa fa-check"></i><b>2.3.2</b> Heston Model</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="2-lt-review.html"><a href="2-lt-review.html#numerical-methods"><i class="fa fa-check"></i><b>2.4</b> Numerical Methods</a><ul>
<li class="chapter" data-level="2.4.1" data-path="2-lt-review.html"><a href="2-lt-review.html#convergence"><i class="fa fa-check"></i><b>2.4.1</b> Convergence</a></li>
<li class="chapter" data-level="2.4.2" data-path="2-lt-review.html"><a href="2-lt-review.html#discretization"><i class="fa fa-check"></i><b>2.4.2</b> Discretization</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="3-implement.html"><a href="3-implement.html"><i class="fa fa-check"></i><b>3</b> The Heston Model Implementation</a><ul>
<li class="chapter" data-level="3.1" data-path="3-implement.html"><a href="3-implement.html#characteristic-function"><i class="fa fa-check"></i><b>3.1</b> Characteristic Function</a></li>
<li class="chapter" data-level="3.2" data-path="3-implement.html"><a href="3-implement.html#euler-scheme"><i class="fa fa-check"></i><b>3.2</b> Euler Scheme</a></li>
<li class="chapter" data-level="3.3" data-path="3-implement.html"><a href="3-implement.html#kahl-jackel"><i class="fa fa-check"></i><b>3.3</b> Kahl-Jackel</a></li>
<li class="chapter" data-level="3.4" data-path="3-implement.html"><a href="3-implement.html#exact-algorithm"><i class="fa fa-check"></i><b>3.4</b> Exact Algorithm</a><ul>
<li class="chapter" data-level="3.4.1" data-path="3-implement.html"><a href="3-implement.html#generate-a-sample-of-v_t-given-v_0"><i class="fa fa-check"></i><b>3.4.1</b> Generate a sample of <span class="math inline">\(V_t\)</span> given <span class="math inline">\(V_0\)</span></a></li>
<li class="chapter" data-level="3.4.2" data-path="3-implement.html"><a href="3-implement.html#generate-a-sample-of-int_0t-v_sds-given-v_t-v_0"><i class="fa fa-check"></i><b>3.4.2</b> Generate a sample of <span class="math inline">\(\int_0^t V_sds\)</span> given <span class="math inline">\(V_t\)</span>, <span class="math inline">\(V_0\)</span></a></li>
<li class="chapter" data-level="3.4.3" data-path="3-implement.html"><a href="3-implement.html#compute-int_0t-sqrtv_sdb_s-given-v_t-v_0-and-int_0t-v_sds"><i class="fa fa-check"></i><b>3.4.3</b> Compute <span class="math inline">\(\int_0^t \sqrt{V_s}dB_s\)</span> given <span class="math inline">\(V_t\)</span>, <span class="math inline">\(V_0\)</span> and <span class="math inline">\(\int_0^t V_sds\)</span></a></li>
<li class="chapter" data-level="3.4.4" data-path="3-implement.html"><a href="3-implement.html#limitations-1"><i class="fa fa-check"></i><b>3.4.4</b> Limitations</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="4-resultados.html"><a href="4-resultados.html"><i class="fa fa-check"></i><b>4</b> Results</a></li>
<li class="chapter" data-level="5" data-path="5-conclusao.html"><a href="5-conclusao.html"><i class="fa fa-check"></i><b>5</b> Conclusion</a></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="A-bsformula.html"><a href="A-bsformula.html"><i class="fa fa-check"></i><b>A</b> Black-Scholes formula</a></li>
<li class="chapter" data-level="B" data-path="B-bessel.html"><a href="B-bessel.html"><i class="fa fa-check"></i><b>B</b> Bessel Function</a></li>
<li class="chapter" data-level="C" data-path="C-imps.html"><a href="C-imps.html"><i class="fa fa-check"></i><b>C</b> Implementations</a><ul>
<li class="chapter" data-level="C.1" data-path="C-imps.html"><a href="C-imps.html#eulerapp"><i class="fa fa-check"></i><b>C.1</b> Euler Scheme</a></li>
<li class="chapter" data-level="C.2" data-path="C-imps.html"><a href="C-imps.html#kjimp"><i class="fa fa-check"></i><b>C.2</b> Kahl-Jackel Implementation</a></li>
<li class="chapter" data-level="C.3" data-path="C-imps.html"><a href="C-imps.html#eabk"><i class="fa fa-check"></i><b>C.3</b> Exact Algorithm</a></li>
<li class="chapter" data-level="C.4" data-path="C-imps.html"><a href="C-imps.html#resultsapp"><i class="fa fa-check"></i><b>C.4</b> Results with 20 steps</a></li>
</ul></li>
<li class="chapter" data-level="D" data-path="D-references.html"><a href="D-references.html"><i class="fa fa-check"></i><b>D</b> References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="implement" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> The Heston Model Implementation</h1>
<p>In section <a href="2-lt-review.html#hes1">2.3.2</a> we presented Heston’s SDE system in one of its structures. Another common way <span class="citation">[31–33]</span> to write down the system is using the property presented in subsection <a href="2-lt-review.html#corr">2.1.2.1</a> as in equation <a href="#eq:heston2">(<strong>??</strong>)</a>.</p>
<span class="math display">\[\begin{align}
\label{eq:heston2}
\begin{split}
dS_t &amp;= r S_t dt + \rho \sqrt{V_t} S_t dB_t + \sqrt{1 - \rho^2} \sqrt{V_t} S_t dW_t \\
dV_t &amp;= k(\theta - V_t)dt + \sigma \sqrt{V_t} dB_t 
\end{split}
\end{align}\]</span>
<div id="characteristic-function" class="section level2">
<h2><span class="header-section-number">3.1</span> Characteristic Function</h2>
<p>The Heston model characteristic function is firstly presented in the 1993 Steven Heston’s paper <span class="citation">[24]</span> and is described below <span class="citation">[34]</span>:</p>
<span class="math display">\[\begin{align}
f(S_t, V_t, t) = e^{A(T-t)+B(T-t)S_t + C(T-t)V_t + i \phi S_t}
\end{align}\]</span>
<p>If we let <span class="math inline">\(\tau = T-t\)</span>, then the explicit form of the Heston characteristic function is:</p>
<span class="math display">\[\begin{align*}
f(i \phi) &amp;= e^{A(\tau)+B(\tau)S_t + C(\tau)V_t + i \phi S_t} \\
A(\tau) &amp;= r i \phi \tau + \frac{\kappa \theta}{\sigma^2} \left[ - (\rho \sigma i \phi - \kappa - M) \tau - 2 \ln\left(\frac{1-N e^{M \tau}}{1-N}\right) \right] \\
B(\tau) &amp;= 0 \\
C(\tau) &amp;= \frac{(e^{M \tau}-1)(\rho \sigma i \phi - \kappa - M)}{\sigma^2 (1-N e^{M \tau})} \\
\text{Where:} &amp; \\
M &amp;= \sqrt{(\rho \sigma i \phi - \kappa)^2 + \sigma^2 (i \phi + \phi^2)} \\
N &amp;= \frac{\rho \sigma i \phi - \kappa - M}{\rho \sigma i \phi - \kappa + M} \\
\end{align*}\]</span>
<p>This function is the driving force behind the following formula, that calculates the fair value of a European call option at time <span class="math inline">\(t\)</span>, given a strike price <span class="math inline">\(K\)</span>, that expires at time <span class="math inline">\(T\)</span> <span class="citation">[34]</span>:</p>
<span class="math display">\[\begin{align} 
\label{eq:cfheston}
\begin{split}
C = &amp; \frac{1}{2} S(t) + \frac{e^{-r(T-t)}}{\pi}\int_{0}^{\infty}{\Re \left[ \frac{K^{-i \phi} f(i \phi + 1)}{i \phi} \right] d\phi} \\
&amp; -Ke^{-r(T-t)}\left( \frac{1}{2} + \frac{1}{\pi} \int_{0}^{\infty}{\Re \left[ \frac{K^{-i \phi} f(i \phi)}{i \phi} \right]}  d\phi \right)
\end{split}
\end{align}\]</span>
</div>
<div id="euler-scheme" class="section level2">
<h2><span class="header-section-number">3.2</span> Euler Scheme</h2>
<p>Given the fact that the underlying asset is temporal dependent upon the solution of the SDE’s volatility, we simulate the volatility’s path before the asset’s. If the Black-Scholes model enabled using Ito’s Lemma directly for solving <span class="math inline">\(S_t\)</span>, this equation system requires numerical methods. We present here the Euler Scheme - Full Truncation algorithm (and compare to other similar schemes) <span class="citation">[31]</span> along with some insights on how it was implemented in R. The Euler discretization brings approximation paths to stock prices and variance processes. If we set <span class="math inline">\(t_0 = 0 &lt; t_1 &lt; \dots &lt; t_M = T\)</span> as partitions of a time interval of <span class="math inline">\(M\)</span> equal segments of length <span class="math inline">\(\delta t\)</span>, we have the following discretization for the stock price:</p>
<span class="math display">\[\begin{align}
S_{t + \Delta t} = S_t + rS_t dt + \sqrt{V_t} S_t Z_s
\end{align}\]</span>
<p>And for the variance process:</p>
<span class="math display">\[\begin{align}
V_{t + \Delta t} = f_1(V_{t}) + \kappa (\theta - f_2(V_{t})) + \sigma \sqrt{f_3(V_{t})} Z_v 
\end{align}\]</span>
<p><span class="math inline">\(Z_s\)</span> being a standard normal random variable, i.e. <span class="math inline">\(N\sim(0,1)\)</span>, we set <span class="math inline">\(Z_t\)</span> and <span class="math inline">\(Z_v\)</span> as two independent standard normal random variables and <span class="math inline">\(Z_s\)</span> and <span class="math inline">\(Z_v\)</span> having correlation <span class="math inline">\(\rho\)</span>. This means we can write <span class="math inline">\(Z_s = \rho Z_v + \sqrt{1-\rho^2} Z_t\)</span>. <span class="math inline">\(r\)</span> is the risk free interest rate.</p>
<p>The immediate observable problem in the proposed discretization scheme is that <span class="math inline">\(V\)</span> can become negative with non-zero probability making the computation of <span class="math inline">\(\sqrt{V_t}\)</span> impossible <span class="citation">[32]</span>. There are several proposed fixes that can be used as you can see below:</p>

<p>Where <span class="math inline">\(V^+ = \max(V,0)\)</span> and <span class="math inline">\(\mid V \mid\)</span> is the absolute value of <span class="math inline">\(V\)</span>.</p>
<p>We chose to fix our discretization using the Full-Truncation (FT) scheme and thus, rewrite the equations as follows:</p>
<span class="math display">\[\begin{align}
\label{eq:st1}
S_{t\Delta} &amp;= S_t + rS_t + \sqrt{V_{t}^{+}} S_t Z_s \\
\label{eq:vt1}
V_{t\Delta} &amp;= V_t + \kappa (\theta - V_{t}^{+}) + \sigma \sqrt{V_{t}^{+}} Z_v 
\end{align}\]</span>
<p>Our R implementation follows the euler’s scheme with hardly any modifications. It draws two Gaussian random variables (<span class="math inline">\(Z_v\)</span> and <span class="math inline">\(Z_t\)</span>) using the function <em>rnorm</em> to create <span class="math inline">\(Z_s\)</span> with correlation <span class="math inline">\(\rho\)</span> with <span class="math inline">\(Z_v\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  Zv &lt;-<span class="st"> </span>stats<span class="op">::</span><span class="kw">rnorm</span>(N)
  Zt &lt;-<span class="st"> </span>stats<span class="op">::</span><span class="kw">rnorm</span>(N)
  Zs &lt;-<span class="st"> </span>rho <span class="op">*</span><span class="st"> </span>Zv <span class="op">+</span><span class="st"> </span>(<span class="kw">sqrt</span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>(rho<span class="op">^</span><span class="dv">2</span>)) <span class="op">*</span><span class="st"> </span>Zt)</code></pre></div>
<p>And use it to compute <span class="math inline">\(S\)</span> and <span class="math inline">\(V\)</span> as in the code snippet bellow. The two modifications we apply are previously computing the square roots of the stepsize <em>dt</em> and the <em>aux</em> variable as to improve speed. The <em>aux</em> variable is an help variable created to impose positivity to <span class="math inline">\(V\)</span> as we are operating the full-truncation euler scheme.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  S &lt;-<span class="st"> </span>S <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>r <span class="op">*</span><span class="st"> </span>dt <span class="op">+</span><span class="st"> </span>sqrt_aux <span class="op">*</span><span class="st"> </span>Zs <span class="op">*</span><span class="st"> </span>sqrt_dt)
  v &lt;-<span class="st"> </span>v <span class="op">+</span><span class="st"> </span>k <span class="op">*</span><span class="st"> </span>dt <span class="op">*</span><span class="st"> </span>(theta <span class="op">-</span><span class="st"> </span>aux) <span class="op">+</span><span class="st"> </span>
<span class="st">                     </span>sigma <span class="op">*</span><span class="st"> </span>sqrt_aux <span class="op">*</span><span class="st"> </span>Zv <span class="op">*</span><span class="st"> </span>sqrt_dt</code></pre></div>
<p>We could have used the <em>pmax</em> function in R, but this function is slow, therefore we opted to create the <em>aux</em> variable and impose positive values using the following R syntax:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  aux &lt;-<span class="st"> </span>v
  aux[v <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span></code></pre></div>
<p>Depending on the reader’s R fluency, other parts of the scheme might present a challenge, and that is why a version of the function is fully presented in appendix <a href="C-imps.html#eulerapp">C.1</a>.</p>
</div>
<div id="kahl-jackel" class="section level2">
<h2><span class="header-section-number">3.3</span> Kahl-Jackel</h2>
<p>Kahl-Jackel propose a discretization method they refer to as the ``IJK’’ method <span class="citation">[32,33]</span> that coupled with the implicit Milstein scheme for the variance lands the system of equations <a href="#eq:kj1">(<strong>??</strong>)</a> and <a href="#eq:kj2">(<strong>??</strong>)</a>. It is possible to verify that this discretization always results in positive paths for <span class="math inline">\(V\)</span> if <span class="math inline">\(4 \kappa \theta &gt; \sigma^2\)</span>. Unfortunately, this inequality is rarely satisfied when we plug real market data to calibrate the parameters. This means we must have a defined strategy for when the inequality doesn’t hold. We use the scheme proposed in Andersen <span class="citation">[32]</span>, where a truncation similar to the Euler’s is applied. Whenever our volatility <span class="math inline">\(V_t\)</span> drops below zero we use <a href="#eq:vt1">(<strong>??</strong>)</a>, and implement <span class="math inline">\(V_{t+\Delta}^{+}\)</span> and <span class="math inline">\(V_t^{+}\)</span> instead of <span class="math inline">\(V_{t+\Delta}\)</span> and <span class="math inline">\(V_t\)</span> of equation <a href="#eq:kj1">(<strong>??</strong>)</a>. The code guidance to this method can be found in appendix <a href="C-imps.html#kjimp">C.2</a>.</p>

</div>
<div id="exact-algorithm" class="section level2">
<h2><span class="header-section-number">3.4</span> Exact Algorithm</h2>
<p>In 2006, Broadie-Kaya <span class="citation">[31]</span> propose a method that has a faster convergence rate, <span class="math inline">\(\mathcal{O} \left( s^{-1/2} \right)\)</span> than some of the more famous schemes, such as Euler’s and Milstein’s discretizations. They build their idea to generate an exact sample from the distribution of the terminal stock price based on numerous papers <span class="citation">[24]</span>. The stock price and variance are as follows:</p>
<span class="math display">\[\begin{align} \label{eq:ea1}
S_t = S_0 \, exp \left[ r t - \frac{1}{2} \int_{0}^{t}{V_s ds} + \rho  \int_{0}^{t}{\sqrt{V_s d B_s}} + \sqrt{1 - \rho^2} \int_{0}^{t}{\sqrt{V_s} dW_s}\right]
\end{align}\]</span>
<p>The squared volatility of the variance process is:</p>
<span class="math display">\[\begin{align} \label{eq:ea2}
V_t = V_0 + \kappa \theta t - \kappa \int_{0}^{t}{V_s ds} + \sigma \int_{0}^{t}{\sqrt{V_s} dB_s}
\end{align}\]</span>
<p>The algorithm used to generate the model consists in four steps as follows:</p>

<div id="generate-a-sample-of-v_t-given-v_0" class="section level3">
<h3><span class="header-section-number">3.4.1</span> Generate a sample of <span class="math inline">\(V_t\)</span> given <span class="math inline">\(V_0\)</span></h3>
<p>The distribution of <span class="math inline">\(V_t\)</span> given <span class="math inline">\(V_0\)</span> for <span class="math inline">\(0 &lt; t\)</span> is a non-central chi-squared distribution <span class="citation">[23,38]</span>:</p>
<p><span class="math display">\[V_t = \frac{\sigma^2 (1-e^{- \kappa t})}{4 \kappa} \chi_{\delta}^{2} \left( \frac{4 \kappa e^{- \kappa t}}{\sigma^2 (1- e^{- \kappa t})} \times V_0\right)\]</span></p>
<p>where <span class="math inline">\(\delta = \frac{4 \theta \kappa}{\sigma^2}\)</span> and <span class="math inline">\(\chi_{\delta}^{2}(\lambda)\)</span> denotes a non-central chi-squared random variable with <span class="math inline">\(\delta\)</span> degrees of freedom and <span class="math inline">\(\lambda\)</span> as its non-centrality parameter.</p>
<p>Broadie and Kaya <span class="citation">[31]</span> sample generating Poisson and gamma distributions as in Johnson et al. <span class="citation">[39]</span>. We used the built-in function in R <em>rchisq</em>, which uses this exact method for sampling, see chunk below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  d1 &lt;-<span class="st"> </span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>k <span class="op">*</span><span class="st"> </span>theta)<span class="op">/</span>(sigma)<span class="op">^</span><span class="dv">2</span>
  c0 &lt;-<span class="st"> </span>(sigma<span class="op">^</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>k<span class="op">*</span>tau)))<span class="op">/</span>(<span class="dv">4</span><span class="op">*</span>k)
  dt &lt;-<span class="st"> </span>(tau<span class="op">-</span>t)

  <span class="co"># sampling V</span>
  lambda &lt;-<span class="st"> </span>(<span class="dv">4</span><span class="op">*</span>k<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>k<span class="op">*</span>dt)<span class="op">*</span>v)<span class="op">/</span>(sigma<span class="op">^</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span>k<span class="op">*</span>dt)))
  vt &lt;-<span class="st"> </span>c0 <span class="op">*</span><span class="st"> </span>stats<span class="op">::</span><span class="kw">rchisq</span>(<span class="dt">n =</span> <span class="dv">1</span>, <span class="dt">df =</span> d1, <span class="dt">ncp =</span> lambda)</code></pre></div>
</div>
<div id="generate-a-sample-of-int_0t-v_sds-given-v_t-v_0" class="section level3">
<h3><span class="header-section-number">3.4.2</span> Generate a sample of <span class="math inline">\(\int_0^t V_sds\)</span> given <span class="math inline">\(V_t\)</span>, <span class="math inline">\(V_0\)</span></h3>
<p>After generating <span class="math inline">\(V_t\)</span>, we proceed to the algorithm’s next step following <span class="citation">[31,39]</span>. We use the characteristic function <a href="#eq:phi">(<strong>??</strong>)</a> to compute the probability density function <span class="math inline">\(F(x)\)</span>.</p>
<span class="math display">\[\begin{align} \label{eq:phi}
\begin{split}
\Phi(a) &amp;= \mathbb{E}\left[ exp \left( ia \int_{0}^{t}{V_s ds} \mid V_0,V_t \right)  \right] \\[10pt]
&amp;= \frac{\gamma(a)e^{(-1/2)(\gamma(a)- \kappa) t} (1 - e^{- \kappa t})}{\kappa (1 - e^{- \gamma(a) t})} \\[10pt]
&amp;\times exp \left\{\frac{V_0 + V_t}{\sigma^2} \left[ \frac{\kappa (1 + e^{- \kappa t})}{1 - e^{- \kappa t}} - \frac{\gamma(a) (1 + e^{- \gamma(a) t})}{1 - e^{- \gamma(a) t}} \right] \right\} \\[10pt]
&amp;\times \frac{I_{0.5\delta - 1} \left[ \sqrt{V_0 V_t} \frac{4 \gamma(a) e^{-0.5 \gamma(a) t}}{\sigma^2 (1 - e^{- \gamma(a) t})} \right]}{I_{0.5\delta - 1}  \left[ \sqrt{V_0 V_t} \frac{4 \kappa e^{-0.5 \kappa t}}{\sigma^2 (1 - e^{- \kappa t})} \right]}
\end{split}
\end{align}\]</span>
<p>where <span class="math inline">\(\gamma(a) = \sqrt{\kappa^2 - 2 \sigma^2 i a}\)</span>, <span class="math inline">\(\delta\)</span> was previously defined and <span class="math inline">\(I_v(x)\)</span> is the modified Bessel function of the first kind.<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> There are no mysteries implementing the characteristic function as you can observe in the chunk below. Although R has a built-in Bessel function, it only accounts for real numbers. Thus, we were obliged to use the Bessel package <span class="citation">[40]</span> that accounts for complex numbers. Once again, we pre compute some of the operations that are repeated through the function as to reduce computational time. This is specially important for this method since it involves operations of high complexity.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  phi_heston &lt;-<span class="st"> </span><span class="cf">function</span>(a, v0, v_t, d){
  
  gamma_a &lt;-<span class="st"> </span><span class="kw">sqrt</span>(k<span class="op">^</span><span class="dv">2</span> <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>sigma<span class="op">^</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>1i<span class="op">*</span>a)
  gammadt &lt;-<span class="st"> </span>gamma_a <span class="op">*</span><span class="st"> </span>(tau<span class="op">-</span>t)
  sqrtv0vt &lt;-<span class="st"> </span><span class="kw">sqrt</span>(v0<span class="op">*</span>v_t)
  delta &lt;-<span class="st"> </span><span class="op">-</span>k <span class="op">*</span><span class="st"> </span>(tau<span class="op">-</span>t)
  
  part1 &lt;-<span class="st"> </span>(gamma_a <span class="op">*</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>(gamma_a <span class="op">-</span><span class="st"> </span>k)<span class="op">/</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(tau<span class="op">-</span>t)) <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">exp</span>(delta)))<span class="op">/</span>
<span class="st">           </span>(k <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span><span class="op">-</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span><span class="st"> </span>gammadt)))
  part2 &lt;-<span class="st"> </span><span class="kw">exp</span>((v0<span class="op">+</span>v_t)<span class="op">/</span>(sigma<span class="op">^</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>( (k <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(delta)))<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(delta)) <span class="op">-</span>
<span class="st">           </span>(gamma_a <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span><span class="st"> </span>gammadt)))<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span><span class="st"> </span>gammadt))))
  part3 &lt;-<span class="st"> </span>Bessel<span class="op">::</span><span class="kw">BesselI</span>(<span class="dt">z =</span> ((<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>gamma_a <span class="op">*</span><span class="st"> </span>sqrtv0vt)<span class="op">/</span>(sigma<span class="op">^</span><span class="dv">2</span>) <span class="op">*</span>
<span class="st">                           </span><span class="kw">exp</span>(<span class="op">-</span><span class="st"> </span>gammadt<span class="op">/</span><span class="dv">2</span>)<span class="op">/</span>
<span class="st">                           </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span><span class="st"> </span>gammadt))), <span class="dt">nu =</span> <span class="fl">0.5</span><span class="op">*</span>d <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span>
<span class="st">           </span>Bessel<span class="op">::</span><span class="kw">BesselI</span>(<span class="dt">z =</span> ((<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>k <span class="op">*</span><span class="st"> </span>sqrtv0vt)<span class="op">/</span>(sigma<span class="op">^</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>
<span class="st">                           </span>(<span class="kw">exp</span>(delta<span class="op">/</span><span class="dv">2</span>))<span class="op">/</span><span class="st"> </span>(<span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(delta))), <span class="dt">nu =</span> <span class="fl">0.5</span><span class="op">*</span>d <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)
  <span class="kw">return</span> (part1 <span class="op">*</span><span class="st"> </span>part2 <span class="op">*</span><span class="st"> </span>part3)
}</code></pre></div>

<p>The probability distribution function is obtained in <span class="citation">[31,38]</span> by Fourier inversions using Feller <span class="citation">[41]</span>. We use the approach in Gil-Pelaez <span class="citation">[42]</span>, equation <a href="#eq:fourier">(<strong>??</strong>)</a>. We define <span class="math inline">\(V(u,t)\)</span> the random variable with the same distribution as the integral <span class="math inline">\(\int_{u}^{t}{V_s ds}\)</span>, conditional on <span class="math inline">\(V_u\)</span> and <span class="math inline">\(V_t\)</span>:</p>
<span class="math display">\[\begin{align} \label{eq:fourier}
F(x) \equiv Pr \left\{ V(u,t) \leq x \right\} = F_{X}(x)={\frac {1}{2}}-{\frac {1}{\pi }}\int _{0}^{\infty }{\frac {\operatorname {Im} [e^{-iux} phi (u)]}{u}}\,du
\end{align}\]</span>
<p><span class="math inline">\(\operatorname {Im}\)</span> denotes the imaginary part of <span class="math inline">\(e^{-iux} phi (u)\)</span>. Equation <a href="#eq:fourier">(<strong>??</strong>)</a> is computed numerically and we then sample it by inversion. The integral function of the volatility is composed by five other functions inside of it. Since it acts only as a wrapper to theses functions we are going to omit it below, but the complete code can be found in appendix <a href="C-imps.html#eabk">C.3</a>.The first represents our integrand. The following function takes our integrand and actually performs the integration, returning the value. For speed purposes, we limited the integral upper bound to 1000 and increased the tolerance to <span class="math inline">\(10^{-3}\)</span>. After these calculations we have now the function’s cumulative function.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  integrand &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">phi =</span> cf){
    
    f2 &lt;-<span class="st"> </span><span class="cf">function</span>(u){
      <span class="kw">Im</span>(<span class="kw">phi</span>(u) <span class="op">*</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>1i <span class="op">*</span><span class="st"> </span>u <span class="op">*</span><span class="st"> </span>x)) <span class="op">/</span>u
    }
    <span class="kw">return</span>(f2)
  }
  
  ## integrate to &quot;cdf&quot;
  F_x &lt;-<span class="st"> </span><span class="cf">function</span> (x) {
    y &lt;-<span class="st"> </span><span class="fl">0.5</span> <span class="op">-</span><span class="st"> </span><span class="dv">1</span><span class="op">/</span>pi <span class="op">*</span><span class="st"> </span>stats<span class="op">::</span><span class="kw">integrate</span>(<span class="kw">integrand</span>(x),  <span class="dt">lower=</span> <span class="dv">0</span>, <span class="dt">upper=</span> <span class="dv">1000</span>,
                                <span class="dt">rel.tol =</span> <span class="fl">0.001</span>, <span class="dt">stop.on.error =</span> <span class="ot">FALSE</span>)<span class="op">$</span>value
    <span class="kw">return</span>(y)
  }
  
  
  ## endsign
  endsign &lt;-<span class="st"> </span><span class="cf">function</span>(f, <span class="dt">sign =</span> <span class="dv">1</span>) {
    b &lt;-<span class="st"> </span>sign
    <span class="cf">while</span> (sign <span class="op">*</span><span class="st"> </span><span class="kw">f</span>(b) <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>) b &lt;-<span class="st"> </span><span class="dv">10</span> <span class="op">*</span><span class="st"> </span>b
    <span class="kw">return</span>(b)
  }</code></pre></div>

<p>After computing the integral, we need to set the inversion function to place. To do that we generate the <em>endsign</em> function above. It is a simple function that is used to guarantee that when we call <em>uniroot</em>, the function to find roots built-in in R, our bounds have different signs. We set our lower and upper bounds as <span class="math inline">\(- \infty\)</span> and <span class="math inline">\(\infty\)</span>, respectively and define and auxiliary function <em>subcdf</em> that will perform the inversion subtracting an uniform from it.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  ## inversion
  low_bound =<span class="st"> </span><span class="op">-</span><span class="ot">Inf</span>
  upp_bound =<span class="st"> </span><span class="ot">Inf</span>
  invcdf &lt;-<span class="st"> </span><span class="cf">function</span>(u) {
    subcdf &lt;-<span class="st"> </span><span class="cf">function</span>(t) <span class="kw">F_x</span>(t) <span class="op">-</span><span class="st"> </span>u
    <span class="cf">if</span> (low_bound <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="ot">Inf</span>)
      low_bound &lt;-<span class="st"> </span><span class="kw">endsign</span>(subcdf, <span class="op">-</span><span class="dv">1</span>)
    <span class="cf">if</span> (upp_bound <span class="op">==</span><span class="st"> </span><span class="ot">Inf</span>)
      upp_bound &lt;-<span class="st"> </span><span class="kw">endsign</span>(subcdf)
    <span class="kw">return</span>(<span class="kw">uniroot</span>(subcdf, <span class="dt">lower=</span>low_bound, <span class="dt">upper=</span>upp_bound, 
                   <span class="dt">tol =</span> <span class="fl">0.001220703</span>)<span class="op">$</span>root)
  }
  U &lt;-<span class="st"> </span>stats<span class="op">::</span><span class="kw">runif</span>(n)
  <span class="kw">sapply</span>(U, invcdf)</code></pre></div>

<p>Furthermore, we also introduce (not in the same simulations, obviously) a simpler version for this step, that computes this integral approximation, using the solution <span class="math inline">\(\int_{u}^{t}{V_s ds} = \frac{1}{2} \left( V_u + V_t \right)\)</span>. This solution is called <em>drift interpolation</em> <span class="citation">[43]</span> and its implementation is out of the box but we provide it anyway:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    int_v &lt;-<span class="st"> </span>dt <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>v <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>vt)</code></pre></div>
</div>
<div id="compute-int_0t-sqrtv_sdb_s-given-v_t-v_0-and-int_0t-v_sds" class="section level3">
<h3><span class="header-section-number">3.4.3</span> Compute <span class="math inline">\(\int_0^t \sqrt{V_s}dB_s\)</span> given <span class="math inline">\(V_t\)</span>, <span class="math inline">\(V_0\)</span> and <span class="math inline">\(\int_0^t V_sds\)</span></h3>
<p>From equation <a href="#eq:ea2">(<strong>??</strong>)</a> we are now able to compute this integral:</p>
<span class="math display">\[\begin{align} \label{eq:ea3}
\int_{0}^{t}{\sqrt{V_s} dB_s} = \frac{V_t - V_0 - \kappa \theta t + \kappa \int_{0}^{t}{V_s ds}}{\sigma} 
\end{align}\]</span>
<p>The last step of the algorithm consists of computing the conditional distribution of <span class="math inline">\(log S_t\)</span> based on the fact that the process for <span class="math inline">\(V_t\)</span> is independent from <span class="math inline">\(dB_t\)</span>, and the distribution of <span class="math inline">\(\displaystyle \int_0^t{\sqrt{V_s} dB_s}\)</span> is normal with mean <span class="math inline">\(0\)</span> and variance <span class="math inline">\(\displaystyle \int_0^t{V_s ds}\)</span>, given <span class="math inline">\(V_t\)</span>.</p>
<p><span class="math display">\[m(u,t) = \log S_0 + \left[ r t - \frac{1}{2} \int_{0}^{t}{V_s ds} + \rho  \int_{0}^{t}{\sqrt{V_s} d B_s} + \sqrt{1 - \rho^2} \int_{0}^{t}{\sqrt{V_s} dW_s}\right]\]</span></p>
<p>and variance</p>
<p><span class="math display">\[\sigma^2(0,t) = \left( 1 - \rho^2 \right) \int_0^t{V_s ds}\]</span></p>
<p>We generate the <span class="math inline">\(S_t\)</span> sample using a standard normal random variable <span class="math inline">\(Z\)</span> and set:</p>
<p><span class="math display">\[S_t = e^{m(0,t) + \sigma (0,t) Z}\]</span></p>
<p>In R code, we have the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  int_vdw &lt;-<span class="st"> </span>(<span class="dv">1</span><span class="op">/</span>sigma) <span class="op">*</span><span class="st"> </span>(vt <span class="op">-</span><span class="st"> </span>v <span class="op">-</span><span class="st"> </span>k <span class="op">*</span><span class="st"> </span>theta <span class="op">*</span><span class="st"> </span>dt <span class="op">+</span><span class="st"> </span>k  <span class="op">*</span><span class="st"> </span>int_v)
  
  m &lt;-<span class="st"> </span><span class="kw">log</span>(S) <span class="op">+</span><span class="st"> </span>(r <span class="op">*</span><span class="st"> </span>(tau <span class="op">-</span><span class="st"> </span>t) <span class="op">-</span><span class="st"> </span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>int_v <span class="op">+</span><span class="st"> </span>rho <span class="op">*</span><span class="st"> </span>int_vdw)
  std &lt;-<span class="st"> </span><span class="kw">sqrt</span>((<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>rho<span class="op">^</span><span class="dv">2</span>)) <span class="op">*</span><span class="st"> </span><span class="kw">sqrt</span>(int_v)
  S &lt;-<span class="st"> </span><span class="kw">exp</span>(m <span class="op">+</span><span class="st"> </span>std <span class="op">*</span><span class="st"> </span>stats<span class="op">::</span><span class="kw">rnorm</span>(<span class="dv">1</span>))</code></pre></div>
</div>
<div id="limitations-1" class="section level3">
<h3><span class="header-section-number">3.4.4</span> Limitations</h3>
<p>The biggest limitation this scheme presents is that the second step is computationally costly. It demands the inversion of the distribution function of <span class="math inline">\(\left( \displaystyle \int_0^t V_sds \mid V_t, \, V_0 \right)\)</span> numerically. We must perform a root search of <span class="math inline">\(F(x_i) - U = 0\)</span> testing for different <span class="math inline">\(x_i\)</span>. Notwithstanding, we do not know the cummulative form of <span class="math inline">\(F(x_i)\)</span> distribution and have to perform our root finding strategy starting from the characteristic function, which contains two modified Bessel functions inside, in a structure that is rerun until a given tolerance <span class="math inline">\(\epsilon\)</span> is reached. Mathematically: <span class="math inline">\(F(x_i) - U = \epsilon\)</span>.</p>
<!-- <!-- Required to number equations in HTML files -->
<!-- <script type="text/x-mathjax-config"> -->
<!-- MathJax.Hub.Config({ -->
<!--   TeX: { equationNumbers: { autoNumber: "AMS" } } -->
<!-- }); -->
<!-- </script> -->

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="2-lt-review.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="4-resultados.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": [["thesis.pdf", "PDF"], ["thesis.epub", "EPUB"], ["thesis.docx", "Word"]],
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
